// @ts-nocheck
const bcrypt=require("bcryptjs"),jwt=require("jsonwebtoken"),Sport=require("../models/Sport"),Match=require("../models/Match"),{generateAccessToken:generateAccessToken,generateRefreshToken:generateRefreshToken}=require("../config/jwt"),fs=require("fs"),path=require("path"),axios=require("axios"),moment=require("moment-timezone"),deepEqual=require("fast-deep-equal"),PremiumEvent=require("../models/PremiumEvent"),currentISTTime=moment().tz("Asia/Kolkata").toDate();exports.syncAllMatches=async(e,t)=>{try{const e=await Sport.find({betfairEventTypeId:{$ne:null}}).select("_id betfairEventTypeId");if(!e.length)return t.status(404).json({message:"No sports with betfairEventTypeId"});let s=0,r=0;const a=[];for(const t of e){const e=t.betfairEventTypeId,n=`https://apidiamond.online/sports/api/final-event-sport-list/${e}`;try{const{data:o}=await axios.get(n),i=o?.sports||o?.result;if(!Array.isArray(i)){console.warn(`Invalid data for sportId ${e}`);continue}const c=[];for(const s of i){const r=s.event_id||s.eventId;if(!r)continue;if(await Match.exists({eventId:r}))continue;let a=null;try{const e=s.event_date;if("number"!=typeof e&&isNaN(Number(e)))"string"!=typeof e||isNaN(Date.parse(e))||(a=new Date(e));else{const t=Number(e);t>1e12?a=new Date(t):t>1e9&&(a=new Date(1e3*t))}}catch(e){a=null}c.push({...s,eventId:r,sport_id:e,sportId:t._id,betfair_event_id:s.betfair_event_id||r,event_date:a})}if(c.length)try{s+=(await Match.insertMany(c,{ordered:!1})).length}catch(t){console.error(`Insert error for sportId ${e}:`,t.message),r+=c.length,a.push(...c.map((e=>({eventId:e.eventId,eventName:e.sportrader_eventName||e.event_name}))))}}catch(t){console.error(`Sync error sportId ${e} :`,t.message);continue}}t.status(200).json({message:"Sync completed (insert only)",totalInserted:s,totalFailed:r,failedMatches:a})}catch(e){console.error("Global sync error:",e.message),t.status(500).json({message:"Server error",error:e.message})}},exports.getMatchesBySportId=async(e,t)=>{try{const{sportId:s}=e.params,r=await Match.find({sportId:parseInt(s)}).sort({startTime:1});t.status(200).json(r)}catch(e){t.status(500).json({message:"Error fetching matches",error:e.message})}},exports.getAllMatches=async(e,t)=>{try{const s=parseInt(e.query.page)||1,r=parseInt(e.query.limit)||20,a=(s-1)*r,n=await Match.find().sort({_id:1}).skip(a).limit(r),o=await Match.countDocuments();t.status(200).json({page:s,limit:r,total:o,totalPages:Math.ceil(o/r),matches:n})}catch(e){t.status(500).json({message:"Failed to fetch matches",error:e.message})}},exports.toggleBetting=async(e,t)=>{try{const{id:s}=e.params,{isBettingEnabled:r}=e.body;if("boolean"!=typeof r)return t.status(400).json({message:"isBettingEnabled must be true or false"});const a=await Match.findByIdAndUpdate(s,{isBettingEnabled:r},{new:!0});if(!a)return t.status(404).json({message:"Match not found"});t.status(200).json({message:"Betting has been "+(r?"enabled":"disabled"),match:a})}catch(e){console.error("Toggle betting error:",e.message),t.status(500).json({message:"Server error",error:e.message})}},exports.getEventSummary=async(e,t)=>{try{const e=await Match.countDocuments(),s=await Match.countDocuments({time:{$lte:currentISTTime}}),r=e-s,a=await Sport.aggregate([{$group:{_id:null,total:{$sum:"$marketCount"}}}]),n=a[0]?.total||0,o=(await Match.distinct("providerId")).length;return t.status(200).json({message:"Event summary fetched successfully",data:{totalEvents:e,liveEvents:s,upcomingEvents:r,activeMarkets:n,providers:o}})}catch(e){return console.error("Error in event summary:",e.message),t.status(500).json({message:"Failed to fetch event summary",error:e.message})}},exports.getAllMatchesBySportId=async(e,t)=>{try{const s=parseInt(e.query.page)||1,r=parseInt(e.query.limit)||20,a=e.params.sportId;console.log(a);const n=(s-1)*r,o={};a&&(o.sportId=a);const i=await Match.find(o).sort({_id:1}).skip(n).limit(r),c=await Match.countDocuments(o);t.status(200).json({page:s,limit:r,total:c,totalPages:Math.ceil(c/r),matches:i})}catch(e){t.status(500).json({message:"Failed to fetch matches",error:e.message})}},exports.syncPremiumEvent=async(e,t)=>{try{const{sportId:s,eventId:r}=e.params;if(!s||!r)return t.status(400).json({message:"sportId and eventId are required"});const{data:a}=await axios.post("https://apidiamond.online/sports/api/v1/feed/betfair-market-in-sr",{sportId:s,eventId:r},{headers:{"Content-Type":"application/json"}});if(!a||0!==a.errorCode||!a.eventId)return t.status(400).json({message:"Invalid or missing data from external API",data:a});const n=await PremiumEvent.findOneAndUpdate({eventId:a.eventId},{$set:a},{new:!0,upsert:!0});t.status(200).json({message:n.createdAt?.getTime()===n.updatedAt?.getTime()?"Inserted new premium event":"Updated existing premium event",_id:n._id,eventId:n.eventId})}catch(e){console.error("Premium sync error:",e.message),t.status(500).json({message:"Server error",error:e.message})}},exports.getPremiumEventByEventId=async(e,t)=>{try{const{eventId:s}=e.params;if(!s)return t.status(400).json({message:"eventId is required"});const r=await PremiumEvent.findOne({eventId:s});if(!r)return t.status(404).json({message:"Premium event not found"});t.status(200).json({message:"Premium event found",data:r})}catch(e){console.error("Error fetching premium event:",e.message),t.status(500).json({message:"Server error",error:e.message})}};