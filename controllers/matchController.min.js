// @ts-nocheck
const bcrypt=require("bcryptjs"),jwt=require("jsonwebtoken"),Sport=require("../models/Sport"),Match=require("../models/Match"),{generateAccessToken:generateAccessToken,generateRefreshToken:generateRefreshToken}=require("../config/jwt"),fs=require("fs"),path=require("path"),axios=require("axios"),moment=require("moment-timezone"),currentISTTime=moment().tz("Asia/Kolkata").toDate();exports.syncAllMatches=async(t,e)=>{try{const t=await Sport.find({betfairEventTypeId:{$ne:null}}).select("_id betfairEventTypeId");if(!t||0===t.length)return e.status(404).json({message:"No sports found with betfairEventTypeId"});let s=0,a=0;for(const e of t){const t=e.betfairEventTypeId;for(const r of[1,0]){const n=`https://apidiamond.online/sports/api/v1/listGames/${t}/${r}`;try{const o=await axios.get(n),i=o.data?.result||o.data?.data;if(!Array.isArray(i)){console.warn(`Invalid match data for sportId ${t}, inPlay=${r}`),console.log("Raw response:",o.data);continue}const c=i.filter((t=>t.event_id)),l=await Match.find({eventId:{$in:c.map((t=>t.event_id))}}).select("eventId"),m=new Set(l.map((t=>t.eventId))),d=c.filter((t=>!m.has(t.event_id))).map((s=>({...s,eventId:s.event_id,sport_id:t,sportId:e._id,betfair_event_id:t,is_in_play:r.toString()})));d.length>0&&await Match.insertMany(d),s+=d.length,a+=m.size}catch(e){console.error(`Failed syncing sportId ${t} (inPlay=${r}):`,e.message);continue}}}return e.status(200).json({message:"Sync completed",totalInserted:s,totalSkipped:a})}catch(t){console.error("Sync error:",t.message),e.status(500).json({message:"Failed to sync matches for all sports",error:t.message})}},exports.getMatchesBySportId=async(t,e)=>{try{const{sportId:s}=t.params,a=await Match.find({sportId:parseInt(s)}).sort({startTime:1});e.status(200).json(a)}catch(t){e.status(500).json({message:"Error fetching matches",error:t.message})}},exports.getAllMatches=async(t,e)=>{try{const s=parseInt(t.query.page)||1,a=parseInt(t.query.limit)||20,r=(s-1)*a,n=await Match.find().sort({_id:1}).skip(r).limit(a),o=await Match.countDocuments();e.status(200).json({page:s,limit:a,total:o,totalPages:Math.ceil(o/a),matches:n})}catch(t){e.status(500).json({message:"Failed to fetch matches",error:t.message})}},exports.toggleBetting=async(t,e)=>{try{const{id:s}=t.params,{isBettingEnabled:a}=t.body;if("boolean"!=typeof a)return e.status(400).json({message:"isBettingEnabled must be true or false"});const r=await Match.findByIdAndUpdate(s,{isBettingEnabled:a},{new:!0});if(!r)return e.status(404).json({message:"Match not found"});e.status(200).json({message:"Betting has been "+(a?"enabled":"disabled"),match:r})}catch(t){console.error("Toggle betting error:",t.message),e.status(500).json({message:"Server error",error:t.message})}},exports.getEventSummary=async(t,e)=>{try{const t=await Match.countDocuments(),s=await Match.countDocuments({event_date:{$lte:currentISTTime}}),a=t-s,r=await Sport.aggregate([{$group:{_id:null,total:{$sum:"$marketCount"}}}]),n=r[0]?.total||0,o=(await Match.distinct("providerId")).length;return e.status(200).json({message:"Event summary fetched successfully",data:{totalEvents:t,liveEvents:s,upcomingEvents:a,activeMarkets:n,providers:o}})}catch(t){return console.error("Error in event summary:",t.message),e.status(500).json({message:"Failed to fetch event summary",error:t.message})}},exports.getAllMatchesBySportId=async(t,e)=>{try{const s=parseInt(t.query.page)||1,a=parseInt(t.query.limit)||20,r=t.params.sportId;console.log(r);const n=(s-1)*a,o={};r&&(o.sportId=r);const i=await Match.find(o).sort({_id:1}).skip(n).limit(a),c=await Match.countDocuments(o);e.status(200).json({page:s,limit:a,total:c,totalPages:Math.ceil(c/a),matches:i})}catch(t){e.status(500).json({message:"Failed to fetch matches",error:t.message})}};