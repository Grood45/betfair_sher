// @ts-nocheck
const axios=require("axios"),Marketlimit=require("../models/Marketlimit"),MarketList=require("../models/Marketlist"),ExchangeOdds=require("../models/ExchangeOdds"),BookmakerMarket=require("../models/BookmakerMarket"),Fancymarket=require("../models/FancyMarket"),PremiumEvent=require("../models/PremiumEvent");exports.getAllLimits=async(e,t)=>{try{const e=await Marketlimit.find().sort({marketType:1});t.status(200).json({message:"Market limits fetched successfully",data:e})}catch(e){t.status(500).json({message:"Failed to fetch market limits",error:e.message})}},exports.createOrUpdateLimit=async(e,t)=>{try{const{marketType:a,minBet:s,maxBet:r,maxProfit:n}=e.body;if(!(a&&s&&r&&n))return t.status(400).json({message:"All fields are required"});const o=await Marketlimit.findOneAndUpdate({marketType:a},{minBet:s,maxBet:r,maxProfit:n},{new:!0,upsert:!0});t.status(200).json({message:"Market limit saved successfully",data:o})}catch(e){t.status(500).json({message:"Failed to save market limit",error:e.message})}},exports.getExchangeOddsByEventId=async(e,t)=>{try{const{eventId:a}=e.params;if(!a)return t.status(400).json({message:"Missing eventId in params"});const[s,r,n]=await Promise.all([ExchangeOdds.find({eventId:a}),Fancymarket.findOne({eventId:a}),Marketlimit.find({})]);if(!s.length)return t.status(404).json({message:"No exchange odds found for this eventId"});const o=r?.BMmarket?.bm1||[];t.status(200).json({message:"Exchange odds fetched successfully",total:s.length,MatchOdds:s,BMmarket:o,MarketLimit:n})}catch(e){console.error("Error fetching exchange odds:",e.message),t.status(500).json({message:"Server error",error:e.message})}},exports.syncMarketList=async(e,t)=>{try{const{eventId:a}=e.params;if(!a)return t.status(400).json({message:"Missing eventId in params"});const s=await syncMarketListByEventId(a),r=(await MarketList.find({"event.id":a},{marketId:1,_id:0})).map((e=>e.marketId)).filter(Boolean);if(0===r.length)return t.status(404).json({message:"No marketIds found after sync"});const n=await axios.get("https://apidiamond.online/sports/api/v1/macthodds/",{params:{ids:r.join(",")}}),o=n.data?.data||[];let d=0,i=0;for(const e of o){const t=await ExchangeOdds.findOne({MarketId:e.MarketId});await ExchangeOdds.findOneAndUpdate({MarketId:e.MarketId},{$set:{MarketId:e.MarketId,eventId:e.eventId,marketName:e.marketName,Status:e.Status,IsInplay:e.IsInplay,updateTime:e.updatetime,sport:e.sport,NumberOfRunners:e.NumberOfRunners,NumberOfActiveRunners:e.NumberOfActiveRunners,TotalMatched:e.TotalMatched,Runners:e.Runners}},{new:!0,upsert:!0}),t?i++:d++}t.status(200).json({message:"Synced, odds fetched and stored",syncSummary:s,marketIds:r,oddsStored:{inserted:d,updated:i}})}catch(e){console.error("Error fetching market list:",e.message),t.status(500).json({message:"Server error",error:e.message})}};const syncMarketListByEventId=async e=>{if(!e)throw new Error("Missing eventId");const t=await axios.post("https://apidiamond.online/sports/api/market-list",{eventId:e}),a=t.data?.data;if(!Array.isArray(a))throw new Error("Invalid market data received");let s=0,r=0;for(const e of a){const t=await MarketList.findOne({marketId:e.marketId});await MarketList.findOneAndUpdate({marketId:e.marketId},{$set:e},{new:!0,upsert:!0}),t?r++:s++}return{inserted:s,updated:r}};exports.syncBookmakerMarkets=async(e,t)=>{try{const{eventId:a}=e.params;if(!a)return t.status(400).json({message:"eventId is required in URL params"});const{data:s}=await axios.get(`https://apidiamond.online/sports/api/v1/exchange/v1/player-operations/fancy/event/details/${a}`);if(!s||"OK"!==s.status||!Array.isArray(s.data))return t.status(400).json({message:"Invalid API response",raw:s});let r=0,n=0;for(const e of s.data){const t=e.categoryDetails,s=e.markets;for(const e of s){const s={eventId:a,marketId:e.marketId},o={eventId:a,marketId:e.marketId,eventName:e.eventName,competitionId:e.competitionId||"",competitionName:e.competitionName||"",market:e,categoryDetails:t,feedTimestamp:new Date},d=await BookmakerMarket.findOne(s);await BookmakerMarket.findOneAndUpdate(s,{$set:o},{new:!0,upsert:!0});d?n++:r++}}t.status(200).json({message:"Bookmaker markets sync completed",eventId:a,inserted:r,updated:n})}catch(e){console.error("Bookmaker sync error:",e.message),t.status(500).json({message:"Server error",error:e})}},exports.syncBmFancyMarkets=async(e,t)=>{try{const{eventId:a}=e.params;if(!a)return t.status(400).json({message:"eventId is required in URL params"});const{data:s}=await axios.get(`https://apidiamond.online/sports/api/v1/bm_fancy/${a}/1`);if(!s||"object"!=typeof s||!s.status||!s.data)return t.status(400).json({message:"Invalid API response structure",raw:s});const{vid:r=a,updatetime:n=Date.now(),update:o="",BMmarket:d={bm1:[]},Fancymarket:i=[]}=s.data,m={status:s.status,eventId:a,vid:r,updatetime:new Date(n),update:o,BMmarket:d,Fancymarket:i},c=await Fancymarket.findOneAndUpdate({eventId:a},{$set:m},{new:!0,upsert:!0});t.status(200).json({message:"BM & Fancy markets synced (flattened)",eventId:a,documentId:c._id})}catch(e){console.error("BM/Fancy sync error:",e.message),t.status(500).json({message:"Server error",error:e.message})}},exports.getFancymarketByEventId=async(e,t)=>{try{const{eventId:a}=e.params;if(!a)return t.status(400).json({message:"Missing eventId in params"});const s=await Fancymarket.findOne({eventId:a});if(!s)return t.status(404).json({message:"No fancymarket data found for this eventId"});const r=s?.Fancymarket||[];t.status(200).json({message:"Fancymarket data fetched successfully",eventId:a,fancymarket:r})}catch(e){console.error("Error fetching fancymarket data:",e.message),t.status(500).json({message:"Server error",error:e.message})}},exports.j7PremiumEvent=async(e,t)=>{try{const{sportId:a,eventId:s}=e.params;if(!a||!s)return t.status(400).json({message:"sportId and eventId are required"});const{data:r}=await axios.post("https://apidiamond.online/sports/api/v1/feed/betfair-market-in-sr",{sportId:a,eventId:s},{headers:{"Content-Type":"application/json"}});if(!r||0!==r.errorCode||!r.eventId)return t.status(400).json({message:"Invalid or missing data from external API",data:r});const n=await PremiumEvent.findOneAndUpdate({eventId:r.eventId},{$set:r},{new:!0,upsert:!0});t.status(200).json({message:n.createdAt?.getTime()===n.updatedAt?.getTime()?"Inserted new premium event":"Updated existing premium event",_id:n._id,eventId:n.eventId})}catch(e){console.error("Premium sync error:",e.message),t.status(500).json({message:"Server error",error:e.message})}};