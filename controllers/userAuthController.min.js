// @ts-nocheck
const bcrypt=require("bcryptjs"),jwt=require("jsonwebtoken"),User=require("../models/User"),{generateAccessToken:generateAccessToken,generateRefreshToken:generateRefreshToken}=require("../config/jwt"),LoginHistory=require("../models/loginHistory");exports.registerPage=(e,s)=>{s.render("auth/register")},exports.signUp=async(e,s)=>{const{username:r,password:o,name:n,mobile:t,role:a}=e.body;try{if(await User.findOne({username:r}))return s.status(400).json({error:"Username already exists"});const e=await bcrypt.hash(o,10),i=new User({username:r,password:e,name:n||null,mobile:t||null,role:a||"user",status:1});await i.save();const c=generateAccessToken({id:i._id}),u=generateRefreshToken({id:i._id});s.status(201).json({message:"Signup successful",username:i.username,role:i.role,accessToken:c,refreshToken:u})}catch(e){console.error(e),s.status(500).json({error:"Internal Server Error"})}},exports.loginPage=(e,s)=>{s.render("auth/login")},exports.loginUser=async(e,s)=>{const{login:r,password:o}=e.body;try{const n=await User.findOne({$or:[{username:r},{mobile:r}]});if(!n)return s.status(400).json({error:"User not found"});if(!await bcrypt.compare(o,n.password))return s.status(400).json({error:"Invalid password"});const t=generateAccessToken({id:n._id}),a=generateRefreshToken({id:n._id}),i=e.ip||e.connection.remoteAddress,c=e.headers["user-agent"];await LoginHistory.create({userId:n._id,ipAddress:i,browser:c});s.status(200).json({message:"Login successful",username:n.username,_id:n._id,role:n.role,accessToken:t,refreshToken:a})}catch(e){console.error(e),s.status(500).json({error:"Server error"})}},exports.refreshToken=(e,s)=>{const r=e.cookies.refreshToken;if(!r)return s.status(401).json({message:"No refresh token, please login"});try{const e=jwt.verify(r,process.env.JWT_REFRESH_SECRET),o=generateAccessToken({id:e.id,mobile:e.mobile});s.cookie("accessToken",o,{...cookieOptions,maxAge:60*parseInt(process.env.ACCESS_TOKEN_EXPIRES)*1e3||9e5}),s.json({accessToken:o})}catch(e){return console.error(e),s.status(403).json({message:"Invalid refresh token"})}},exports.logout=async(e,s)=>{const r=e.userId,o=await LoginHistory.findOne({userId:r}).sort({loginDate:-1});o&&(o.logoutDate=new Date,await o.save()),s.status(200).json({message:"Logged out successfully"})},exports.getLoginHistory=async(e,s)=>{try{const r=e.userId;if(!r)return s.status(400).json({error:"userId is required"});const o=await LoginHistory.find({userId:r}).sort({loginDate:-1});s.status(200).json({message:"Login history fetched successfully",data:o})}catch(e){console.error("Error fetching login history:",e),s.status(500).json({error:"Internal Server Error"})}};