// @ts-nocheck
const bcrypt=require("bcryptjs"),jwt=require("jsonwebtoken"),User=require("../models/User"),Role=require("../models/Role"),{generateAccessToken:generateAccessToken,generateRefreshToken:generateRefreshToken}=require("../config/jwt"),LoginHistory=require("../models/loginHistory");exports.registerPage=(e,s)=>{s.render("auth/register")},exports.signUp=async(e,s)=>{const{username:r,password:o,name:n,mobile:t,role:a}=e.body;try{if(await User.findOne({username:r}))return s.status(400).json({error:"Username already exists"});const e=await bcrypt.hash(o,10),i=new User({username:r,password:e,name:n||null,mobile:t||null,role:a||"user",status:1});await i.save();const u=generateAccessToken({id:i._id}),c=generateRefreshToken({id:i._id});s.status(201).json({message:"Signup successful",username:i.username,role:i.role,accessToken:u,refreshToken:c})}catch(e){console.error(e),s.status(500).json({error:"Internal Server Error",msg:e.message})}},exports.loginPage=(e,s)=>{s.render("auth/login")},exports.loginUser=async(e,s)=>{const{login:r,password:o}=e.body;try{const n=await User.findOne({$or:[{username:r},{mobile:r}]});if(!n)return s.status(400).json({error:"User not found"});if(!await bcrypt.compare(o,n.password))return s.status(400).json({error:"Invalid password"});const t={id:n._id,role:n.role,username:n.username},a=generateAccessToken(t),i=generateRefreshToken(t),u=e.ip||e.connection.remoteAddress,c=e.headers["user-agent"];await LoginHistory.create({userId:n._id,ipAddress:u,browser:c});s.status(200).json({message:"Login successful",username:n.username,_id:n._id,role:n.role,accessToken:a,refreshToken:i})}catch(e){console.error(e),s.status(500).json({error:"Server error"})}},exports.refreshToken=(e,s)=>{const{refreshToken:r}=e.body;if(!r)return s.status(401).json({message:"No refresh token provided"});try{const e=jwt.verify(r,process.env.JWT_REFRESH_SECRET),o=generateAccessToken({id:e.id});s.status(200).json({accessToken:o})}catch(e){return console.error("Refresh token error:",e),s.status(403).json({message:"Invalid or expired refresh token"})}},exports.logout=async(e,s)=>{const r=e.user.id,o=await LoginHistory.findOne({userId:r}).sort({loginDate:-1});o&&(o.logoutDate=new Date,await o.save()),s.status(200).json({message:"Logged out successfully"})},exports.getLoginHistory=async(e,s)=>{try{const r=e.userId;if(!r)return s.status(400).json({error:"userId is required"});const o=await LoginHistory.find({userId:r}).sort({loginDate:-1});s.status(200).json({message:"Login history fetched successfully",data:o})}catch(e){console.error("Error fetching login history:",e),s.status(500).json({error:"Internal Server Error",msg:e.message})}},exports.createRole=async(e,s)=>{try{const{staffId:r,roleName:o,menus:n}=e.body;if(!r||!o||!Array.isArray(n))return s.status(400).json({message:"staffId, roleName, and menus[] are required"});if(!e.user||"superadmin"!==e.user.role)return s.status(403).json({message:"Only superadmin can assign roles"});const t=await User.findById(r);return t?(t.role=o,t.customMenus=n,t.creatorId||(t.creatorId=e.user.id),await t.save(),s.status(200).json({message:"Role and menus assigned to staff",user:{_id:t._id,name:t.name,role:t.role,customMenus:t.customMenus}})):s.status(404).json({message:"Staff user not found"})}catch(e){return console.error("Assign role error:",e),s.status(500).json({message:"Internal server error",error:e.message})}};